# Домашнее задание № 4

Домашнее задание посвящено продвинутым фишкам PostgreSQL - служебным таблицам и служебным функциям,
а так же возможности разработки пользовательских функций).

## Служебные функции БД

Используя функцию определения размера таблицы, вывести top-5 самых больших таблиц базы.

Подсказка: воспользуйтесь таблицей information_schema.tables, которая хранит информацию обо всех таблицах в базе данных.

## Специфические функции Postgres

Используя специальные функции Postgres, найдём пользователей с самыми похожими вкусами, на основе просмотренных фильмов.

1) Используя функцию array_agg собрать в массив все фильмы, просмотренные пользователем. 
При этом повторов в списке контента быть не должно. Назовём эту конструкцию ЗАПРОС1. Выборка должна содержать два поля: userid и user_views

<pre>
SELECT userID, array_agg(movieId) as user_views FROM ratings WHERE userID=1;
</pre>

2) Создайте таблицу user_movies_agg, в которую сохраните результат запроса
<pre>
SELECT userID, user_views INTO public.user_movies_agg FROM (ЗАПРОС1) WHERE userID=1;
</pre>

3) Используя следующий синтаксис, создайте функцию cross_arr оторая принимает на вход два массива arr1 и arr2. 
Функция возвращает массив, который представляет собой пересечение контента из обоих списков.

Примечание - по именам к аргументам обращаться не получится, придётся делать через $1 и $2.

Подсказка: используйте SQL оператор [INTERSECT](https://github.com/Dju999/flask_docker_app/blob/master/slides/sql_simple_dataset_merge.md).

<pre>
CREATE OR REPLACE FUNCTION cross_arr (int[], int[]) RETURNS int[] language sql as $FUNCTION$ тело_функции ; $FUNCTION$;
</pre>

Тело_функции - это SQL запрос. В этом запросе нужно сделать INTERSECT между UNNEST(arr1) и UNNEST(arr2).
Из результата INTERSECT нужно снова сделать массив.

ПРИМЕЧАНИЕ: сначала попробуйте, как работают функции UNNEST и array_agg в консоли, а потом уже переносите в файл hw4.sql.

4) Сформируйте запрос следующего вида: достать из таблицы всевозможные наборы u1, r1, u2, r2.
u1 и u2 - это id пользователей
r1 и r2 - соответствующие массивы рейтингов

Тривиальных пар (где u1==u2) быть не должно. Назовём эту конструкцию ЗАПРОС1. Результат ЗАПРОС1 оформите как CTE.

Примените к CTE функцию cross_arr. Результатом запроса будут три поля - u1, u2, crossed_array - id двух пользователей и их общие фильмы. Назовём эту конструкцию (вместе с CTE) ЗАПРОС2

Сохраним результат ЗАПРОС2 в таблицу common_user_views, куда сохраните результат запроса.

<pre>
WITH WITH user_pairs as (
  SELECT 1 as u1, 2 as u2, 1 as ar1, 2 as ar2
) SELECT u1, u2, cross_arr(ar1, ar2) INTO common_user_views FROM user_pairs;
</pre>

Отсортируйте выборку из common_user_views по длине crossed_array и оставите топ-10 пользователей с самыми большими пересечениями.

Создайте по аналогии с cross_arr функцию diff_arr, которая вычитает один массив из другого.

Подсказка: используйте оператор SQL [EXCEPT](https://github.com/Dju999/flask_docker_app/blob/master/slides/sql_simple_dataset_merge.md).

<pre>
CREATE OR REPLACE FUNCTION diff_arr (int[], int[]) RETURNS int[] language sql as $FUNCTION$ тело_функции ; $FUNCTION$;
</pre>

Сформируйте рекомендации - для каждой пары посоветуйте для u1 контент, который видел u2, но не видел u1 (в виде массива).

Подсказка: нужно заджойнить user_movies_agg и common_user_views и применить вашй функцию к соответствующим полям.


Итоговая выборка:
<pre>
u1 recs1
u2 recs2
u3 recs3
...
</pre>

Дополнительные подсказки есть в файле hw4.sql.
